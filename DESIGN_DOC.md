# Project Plan: Hilly Route Finder

## 1. Project Objective

To develop a command-line tool in Rust that discovers novel, high-ascent circular running routes of a specified length ($N$ km). The primary goal is to aid in training for a hilly ultra-marathon (75km distance, 2.5km ascent) by finding optimal training routes in an area with limited elevation changes (Oxfordshire).

### Key Success Criteria:
* **Novelty:** Routes generated must be new combinations of paths, not just pre-existing routes from a database.
* **Optimization Goal:** Maximize total ascent for a given target distance $N$.
* **Route Constraints:**
    * Routes must be simple cycles (no repeated segments or intersections).
    * Routes must start and finish at the same point.
    * Routes should prioritize trails and footpaths but can include quiet roads to ensure connectivity.

---

## 2. Technical Stack Overview

* **Core Language:** Rust
* **Geospatial Data:**
    * **Paths/Roads:** OpenStreetMap (OSM) data, specifically in PBF format.
    * **Elevation:** Shuttle Radar Topography Mission (SRTM) 1 Arc-Second data.
* **Key Rust Crates:**
    * **Graph Structure:** `petgraph` for creating and manipulating the route network.
    * **OSM Parsing:** `osmpbf` for efficiently reading the binary OSM data.
    * **Elevation Parsing:** `gdal` for reading SRTM GeoTIFF/HGT files.
    * **Geospatial Types:** `geo` for handling coordinates, distances (Haversine), and path geometries.
* **Visualization:** Leaflet.js, with HTML/JavaScript generated by the Rust application.

---

## 3. Phase 1: Geospatial Data Acquisition and Graph Construction

**Objective:** Convert raw OpenStreetMap data into a clean, filtered graph of runnable paths and intersections.

### 3.1. Data Acquisition and Preparation
1.  **Source:** Download a map extract covering the area of interest (e.g., 40km radius around home).
2.  **Format:** Use the OpenStreetMap export tool to get an `.osm` file. Convert it to the more efficient binary `.pbf` format using a utility like `osmconvert`.

### 3.2. Graph Modeling Strategy
The core idea is to simplify the complex OSM data model into a graph where nodes are only decision points (intersections) and edges represent the full path between those points.

* **Graph Nodes (`petgraph::Node`):** Represent intersections. An OSM node qualifies as a graph node if it is part of **two or more** valid ways.
    * *Node Data:* Store the OSM Node ID and geographic coordinates (`(latitude, longitude)`).
* **Graph Edges (`petgraph::Edge`):** Represent the continuous path segment connecting two intersection nodes.
    * *Edge Data (Initial):* Store the full sequence of intermediate geographic coordinates that trace the path of the edge. This is crucial for accurate distance and elevation calculation later.

### 3.3. Rust Implementation Details (Parsing and Filtering)
1.  **First Pass - Node Identification:**
    * Initialize a `HashMap<osm_node_id, reference_count>`.
    * Parse the PBF file using `osmpbf`. Iterate through all **Ways**.
    * Apply filters to each Way based on its tags:
        * **Include Tags:** `highway` in [`path`, `footway`, `track`, `bridleway`, `cycleway`, `residential`, `unclassified`, `tertiary`].
        * **Exclude Tags:** `highway` in [`motorway`, `primary`, `trunk`] OR `access` in [`private`, `no`].
    * For every valid Way, increment the `reference_count` for each constituent OSM node ID in the HashMap.

2.  **Second Pass - Graph Building:**
    * Initialize a `petgraph::Graph`. Create a `HashMap<osm_node_id, petgraph::NodeIndex>` to map between OSM IDs and graph indices.
    * Iterate through the identified intersection nodes (where `reference_count > 1`) and add them as nodes to the `petgraph` graph. Populate the mapping HashMap.
    * Re-iterate through the valid Ways. For each Way, trace along its node sequence:
        * When an intersection node is found, start a new edge definition.
        * Collect all subsequent non-intersection nodes; these define the shape of the edge.
        * When the next intersection node is found, create the edge in `petgraph` connecting the start and end intersection nodes. Store the collected intermediate coordinates as part of the edge weight.

---

## 4. Phase 2: Elevation Data Integration and Edge Weighting

**Objective:** Enrich the graph edges with accurate distance and elevation gain/loss data derived from SRTM.

### 4.1. Data Acquisition
1.  **Source:** Download SRTM 1 Arc-Second (30m resolution) data from a provider like USGS EarthExplorer or OpenTopography.
2.  **Format:** Data typically comes in GeoTIFF (`.tif`) or `.hgt` format.

### 4.2. Edge Annotation Process
Iterate through every edge in the `petgraph` created in Phase 1. For each edge:

1.  **Retrieve Coordinates:** Get the stored list of intermediate coordinates for the edge: `[coord1, coord2, coord3, ..., coordN]`.
2.  **Load Elevation Model:** Open the SRTM file using the `gdal` crate.
3.  **Calculate Weights:** Initialize `total_distance = 0.0`, `total_ascent = 0.0`, `total_descent = 0.0`. Iterate from `i = 1` to `N-1`:
    * **Distance Calculation:** Calculate the distance between `coord[i]` and `coord[i+1]` using the Haversine formula (available in the `geo` crate). Add to `total_distance`.
    * **Elevation Sampling:** Look up the elevation for `coord[i]` and `coord[i+1]` from the SRTM data.
    * **Ascent/Descent Accumulation:** Calculate `delta = elevation[i+1] - elevation[i]`.
        * If `delta > 0`, add `delta` to `total_ascent`.
        * If `delta < 0`, add `abs(delta)` to `total_descent`.
4.  **Update Edge Weight:** Store the final `total_distance`, `total_ascent`, and `total_descent` values back into the edge data structure in the graph. The edge now fully describes the cost and gain of traversing it.

---

## 5. Phase 3: Route Generation Algorithm Design

**Objective:** Search the weighted graph for simple cycles that match the user's criteria (target length $N$, maximized ascent).

### 5.1. Problem Definition
Find a simple cycle $C$ starting and ending at a home node $v_{home}$, such that:
1.  **Length Constraint:** $\sum_{e \in C} e.distance \approx N$ km.
2.  **Optimization Function:** Maximize $\sum_{e \in C} e.ascent$.

### 5.2. Algorithm Option 1: Constrained Depth-First Search (DFS)
A baseline approach suitable for finding *any* valid route, but less efficient for optimization.

* **Logic:** Implement a recursive DFS traversal starting from $v_{home}$.
* **State Tracking:** Maintain the current path, total distance, total ascent, and a set of visited nodes for the current path.
* **Constraints during Search:**
    * **No Repeats:** Before visiting a node, check if it's already in the current path's visited set. If yes, backtrack (unless it's the start node and a loop is being closed).
    * **Length Pruning:** If `current_distance` exceeds `N * (1 + tolerance)`, backtrack immediately. This significantly reduces the search space.
* **Result:** A collection of valid routes that meet the length criteria, from which the best can be selected.

### 5.3. Algorithm Option 2: Heuristic Optimization (Recommended for Maximization)
Since finding the absolute optimum route is computationally hard, use a metaheuristic like a Genetic Algorithm (GA) to find near-optimal solutions.

* **Population:** Generate an initial population of diverse, valid cycles using a randomized version of Algorithm 1.
* **Chromosome:** A route represented as an ordered list of node indices.
* **Fitness Function:** Define a function to score each route. A good function balances ascent gain with length accuracy.
    * `length_penalty = abs(route_length - target_length)`
    * `fitness_score = total_ascent - (penalty_factor * length_penalty)`
* **Evolutionary Operations:**
    * **Selection:** Favor routes with higher fitness scores as parents for the next generation.
    * **Crossover:** Combine segments from two parent routes to create a new child route. For example, find common nodes between two routes and swap the path segments between them. Ensure the resulting child remains a valid simple cycle.
    * **Mutation:** Introduce small changes to a route, such as rerouting a small portion of the path between two nodes via an alternative path found by a local search (e.g., Dijkstra's algorithm on ascent/distance ratio).

---

## 6. Phase 4: Visualization and Export

**Objective:** Create a simple, shareable visualization of the final generated route(s).

* **Method:** The Rust program will output a self-contained `.html` file.
* **Technology:** Use **Leaflet.js** for rendering.
* **Process:**
    1.  The Rust executable takes the coordinate list of the best route found in Phase 3.
    2.  It formats this list into a JavaScript array string: `var routeCoords = [[lat1, lon1], [lat2, lon2], ...];`.
    3.  This JavaScript array is embedded into an HTML template containing Leaflet initialization code.
    4.  The template code will:
        * Load OpenStreetMap map tiles.
        * Create a `L.polyline` object using `routeCoords`.
        * Add the polyline to the map.
        * Automatically zoom the map to fit the bounds of the generated route (`map.fitBounds(...)`).
