# Route Generation Algorithm

The core of this application is a route generation algorithm designed to find high-ascent circular routes of a specific target distance. The algorithm is implemented in `src/route_generator.rs` and uses a heuristic-based iterative approach.

## 1. Initialization

1.  **Starting Point:** The algorithm begins from a single starting node in the graph, which is determined by finding the nearest graph node to a randomly selected parking location.
2.  **Initial Route:** A small, simple loop is created as the initial route. This is done by finding the nearest neighbor to the starting node and creating a route that goes from `start -> neighbor -> start`. This ensures the route is a valid cycle from the beginning.
3.  **Used Edges:** A `HashSet` is initialized to keep track of the graph edges that have been included in the route. This is used to prevent the algorithm from selecting the same path segment multiple times in later steps.

## 2. Iterative Expansion

The algorithm iteratively expands and improves the route until it reaches the target distance or an iteration limit. The main loop consists of the following steps:

1.  **Candidate Generation:** In each iteration, the algorithm generates `N` (currently 10) candidate route expansions. A candidate is generated by:
    a.  Randomly selecting a segment (an edge between two nodes, `u` and `v`) from the current route.
    b.  Calling `find_alternative_path` to find a new path between `u` and `v`.

2.  **`find_alternative_path` Function:** This function uses the A* search algorithm to find a new path between the two nodes of the selected segment.
    a.  **Cost Function:** The A* cost function is `distance / (ascent + 1.0)`. This heuristic encourages the selection of paths that have a good ratio of ascent to distance. The `+ 1.0` is to prevent division by zero for flat segments.
    b.  **Constraints:**
        i.  The A* search will not consider edges that are already part of the current route (the `used_edges` set).
        ii. The new path must consist of more than two nodes to be considered a valid alternative (i.e., it can't be the original direct edge).
        iii. The new path's distance is constrained. It cannot be excessively longer than the original segment's distance. The current formula for the maximum allowed distance is `original_distance * 4.0 + 1000.0`.

3.  **Candidate Evaluation and Selection:**
    a.  If `find_alternative_path` returns a valid new path, a new candidate route is created by replacing the original segment with the new path.
    b.  The total distance and ascent of this new candidate route are calculated.
    c.  The candidate is scored based on its total ascent.
    d.  After generating `N` candidates, they are sorted by their score in descending order.
    e.  The algorithm then randomly selects one of the top `M` (currently 3) candidates to be the new `current_route` for the next iteration. This element of randomness helps the algorithm to explore different paths and avoid getting stuck in local optima.

## 3. Termination

The iterative process terminates when either of the following conditions is met:
1.  The total distance of the current route exceeds the `target_distance`.
2.  The number of iterations reaches the `iteration_limit`.

Once the loop terminates, the final route is returned as a sequence of `EdgeData` structs, which is then used to generate the visualization map.
